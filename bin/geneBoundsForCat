#!/usr/bin/env python3

import argparse
from collections import defaultdict, namedtuple
from pycbio.sys import fileOps
from pycbio.sys.symEnum import SymEnum
from pycbio.hgdata.genePred import GenePredReader
from pycbio.tsv import TsvTable
from pycbio.hgdata.bed import BedReader
from geneFamilyLib import GeneBoundsBed, buildGeneBounds

class NameColumn(SymEnum):
    geneId = 1
    geneSym = 2

def parseArgs():
    usage = """Get bounds of genes for CAT gp + gp_info"""
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument('--hgncOnly', action="store_true")
    parser.add_argument('--nameField', choices=(NameColumn.geneId, NameColumn.geneSym),
                        default=NameColumn.geneId, type=NameColumn,
                        help="which column to use for in name and for grouping into genes")
    parser.add_argument('--geneType', action='append',
                        help='type of gene, maybe repeated')
    parser.add_argument('--sourceAnnot',
                        help='''BED of source genes for expansion checking and exon counts''')
    parser.add_argument('--maxSourceExpansion', type=float,
                        help='max fraction of size source alignment increase (e.g. 1.5)')
    parser.add_argument('--minExons', type=int,
                        help='minimum number of exons')
    parser.add_argument('catGenePred',
                        help="gp from cat")
    parser.add_argument('catGenePredInfo',
                        help="associateInfo")
    parser.add_argument('geneBoundsBed',
                        help="BED for each gene bounds, score field has number to distinguish between multiple mappings of the same gene.")
    args = parser.parse_args()
    if args.geneType is not None:
        args.geneType = frozenset(args.geneType)
    if (args.maxSourceExpansion is not None) and (args.sourceAnnot is None):
        parser.error('--maxSourceExpansion requires --sourceAnnot')
    if (args.minExons is not None) and (args.sourceAnnot is None):
        parser.error('--minExons requires --sourceAnnot')
    return args

class BoundsOpts(namedtuple("BoundsOpts",
                            ("nameField", "hgncOnly", "geneTypes", "sourceAnnots",
                             "maxSourceExpansion", "minExons",))):
    pass


def loadSourceAnnotBed(sourceAnnotBed):
    return {b.name: b for b in BedReader(sourceAnnotBed)}

def isHgnc(v):
    return v not in ("", "NULL")

def checkSourceExpansion(gp, sourceRec, maxSourceExpansion):
    srcSize = sourceRec.chromEnd - sourceRec.chromStart
    destSize = gp.txEnd - gp.txStart
    return ((destSize - srcSize) / srcSize) <= maxSourceExpansion

def useAnnot(gp, catMeta, opts):
    if not (((not opts.hgncOnly) or isHgnc(catMeta.hgncId))
            and ((opts.geneTypes is None) or (catMeta.gene_biotype in opts.geneTypes))):
        return False
    if opts.sourceAnnots is not None:
        sourceRec = opts.sourceAnnots[gp.name]
        if (opts.maxSourceExpansion is not None) and not checkSourceExpansion(gp, sourceRec, opts.maxSourceExpansion):
            return False
        if (opts.minExons is not None) and (sourceRec.blockCount < opts.minExons):
            return False
    return True

def loadGenesMeta(catGpInfo):
    return TsvTable(catGpInfo, uniqKeyCols=("transcript_id",))

def loadTrans(catGp, catMetaTbl, opts):
    "filter bases on parameters"
    geneTransBeds = defaultdict(list)

    if opts.nameField == NameColumn.geneId:
        nameFld = "gene_id"
    elif opts.nameField == NameColumn.geneSym:
        nameFld = "source_gene_common_name"

    for gp in GenePredReader(catGp):
        catMeta = catMetaTbl.idx.transcript_id[gp.name]
        if useAnnot(gp, catMeta, opts):
            b = GeneBoundsBed(gp.chrom, gp.txStart, gp.txEnd, getattr(catMeta, nameFld), 0, gp.strand,
                              extraCols=(catMeta.source_gene_common_name, catMeta.hgnc_id, catMeta.gene_id, catMeta.gene_biotype))
            geneTransBeds[getattr(catMeta, nameFld)].append(b)
    return geneTransBeds

def main(args):
    sourceAnnots = loadSourceAnnotBed(args.sourceAnnot) if args.sourceAnnot is not None else None
    opts = BoundsOpts(nameField=args.nameField,
                      hgncOnly=args.hgncOnly,
                      geneTypes=args.geneType,
                      sourceAnnots=sourceAnnots,
                      maxSourceExpansion=args.maxSourceExpansion,
                      minExons=args.minExons)
    catMetaTbl = loadGenesMeta(args.catGpInfo)
    geneTransBeds = loadTrans(args.catGp, catMetaTbl, opts)
    with fileOps.opengz(args.geneBoundsBed, "w") as bedFh:
        buildGeneBounds(geneTransBeds, bedFh)

main(parseArgs())
