#!/usr/bin/env python3

import argparse
from collections import defaultdict, deque, namedtuple
from pycbio.sys import fileOps
from pycbio.sys.symEnum import SymEnum
import pyBigWig
from pycbio.hgdata.bed import BedReader
from geneFamilyLib import GeneBoundsBed

class NameColumn(SymEnum):
    geneId = 1
    geneSym = 2

def parseArgs():
    usage = """Get bounds of genes for bigBlatPsl format alignments which have some extra columns."""
    parser = argparse.ArgumentParser(description=usage)
    parser.add_argument('--hgncOnly', action="store_true")
    parser.add_argument('--nameField', choices=(NameColumn.geneId, NameColumn.geneSym),
                        default=NameColumn.geneId, type=NameColumn,
                        help="which column to use for in name and for grouping into genes")
    parser.add_argument('--geneType', action='append',
                        help='type of gene, maybe repeated')
    parser.add_argument('--sourceAnnot',
                        help='''BED of source genes for expansion checking and exon counts''')
    parser.add_argument('--maxSourceExpansion', type=float,
                        help='max fraction of size source alignment increase (e.g. 1.5)')
    parser.add_argument('--minExons', type=int,
                        help='minimum number of exons')
    parser.add_argument('bigBlatPsl',
                        help="must follow bigBlatPsl.as")
    parser.add_argument('geneBoundsBed',
                        help="BED for each gene bounds, score field has number to distinguish between multiple mappings of the same gene.")
    args = parser.parse_args()
    if args.geneType is not None:
        args.geneType = frozenset(args.geneType)
    if (args.maxSourceExpansion is not None) and (args.sourceAnnot is None):
        parser.error('--maxSourceExpansion requires --sourceAnnot')
    if (args.minExons is not None) and (args.sourceAnnot is None):
        parser.error('--minExons requires --sourceAnnot')
    return args

class BoundsOpts(namedtuple("BoundsOpts",
                            ("nameField", "hgncOnly", "geneTypes", "sourceAnnots",
                             "maxSourceExpansion", "minExons",))):
    pass

# offset by -3 due in bigBed
nameColumnIdx = 0
strandColumnIdx = 2
exonCountColumnIdx = 6
geneSymColumnIdx = 22
geneIdColumnIdx = 23
hgncIdColumnIdx = 24
geneTypeColumnIdx = 25

def loadSourceAnnotBed(sourceAnnotBed):
    return {b.name: b for b in BedReader(sourceAnnotBed)}

def isHgnc(v):
    return v not in ("", "NULL")

def checkSourceExpansion(entry, row, sourceRec, maxSourceExpansion):
    srcSize = sourceRec.chromEnd - sourceRec.chromStart
    destSize = entry[1] - entry[0]
    return ((destSize - srcSize) / srcSize) <= maxSourceExpansion

def useAnnot(entry, row, opts):
    if not (((not opts.hgncOnly) or isHgnc(row[hgncIdColumnIdx]))
            and ((opts.geneTypes is None) or (row[geneTypeColumnIdx] in opts.geneTypes))):
        return False
    if opts.sourceAnnots is not None:
        sourceRec = opts.sourceAnnots[row[nameColumnIdx]]
        if (opts.maxSourceExpansion is not None) and not checkSourceExpansion(entry, row, sourceRec, opts.maxSourceExpansion):
            return False
        if (opts.minExons is not None) and (sourceRec.blockCount < opts.minExons):
            return False
    return True

def loadGeneTransBeds(bbpFh, chrom, chromSize, opts):
    "filter bases on parameters"
    geneTransBeds = defaultdict(list)

    if opts.nameField == NameColumn.geneId:
        nameIdx = geneIdColumnIdx
    elif opts.nameField == NameColumn.geneSym:
        nameIdx = geneSymColumnIdx
    for entry in bbpFh.entries(chrom, 0, bbpFh.chroms(chrom)):
        row = entry[2].split('\t')
        if useAnnot(entry, row, opts):
            b = GeneBoundsBed(chrom, entry[0], entry[1], row[nameIdx], 0, row[strandColumnIdx],
                              extraCols=(row[geneSymColumnIdx], row[hgncIdColumnIdx], row[geneIdColumnIdx], row[geneTypeColumnIdx],))
            geneTransBeds[row[nameIdx]].append(b)
    return geneTransBeds

def overlaps(b1, b2):
    return (b1.strand == b2.strand) and (b1.start < b2.end) and (b1.end > b2.start)

def merge(b1, b2):
    b = GeneBoundsBed(b1.chrom, min(b1.start, b2.start), max(b1.end, b2.end), b1.name, 0, b1.strand, extraCols=b1.extraCols)
    b.addGeneIds(b2.geneIds)
    return b

def mergeOrAdd(outRanges, inBed):
    for i in range(len(outRanges)):
        if overlaps(outRanges[i], inBed):
            outRanges[i] = merge(outRanges[i], inBed)
            return True
    outRanges.append(inBed)
    return False

def clusterPass(inRanges, outRanges):
    mergedSome = False
    while len(inRanges) > 0:
        if mergeOrAdd(outRanges, inRanges.pop()):
            mergedSome = True
    return mergedSome

def clusterGeneTrans(transBeds):
    "cluster transcripts for a gene into overlapping beds"
    inRanges = deque(transBeds)
    outRanges = deque()
    while True:
        if not clusterPass(inRanges, outRanges):
            break
        inRanges, outRanges = outRanges, inRanges
    assert len(inRanges) == 0
    return list(outRanges)

def clusterGenes(geneTransBeds):
    "cluster all genes ranges on a chrom so we can sort"
    genesRanges = []
    for transBeds in geneTransBeds.values():
        genesRanges.extend(clusterGeneTrans(transBeds))
    return genesRanges

def setLociNumbers(genesRanges, geneIdLociCounts):
    for gr in genesRanges:
        gr.score = geneIdLociCounts[gr.name]
        geneIdLociCounts[gr.name] += 1

def geneBoundsForChrom(bbpFh, chrom, chromSize, geneIdLociCounts, opts, bedFh):
    "one chrom at a time to save memory"
    geneTransBeds = loadGeneTransBeds(bbpFh, chrom, chromSize, opts)
    genesRanges = clusterGenes(geneTransBeds)
    setLociNumbers(genesRanges, geneIdLociCounts)
    for geneRange in sorted(genesRanges, key=lambda b: (b.start, -b.end)):
        geneRange.write(bedFh)

def geneBoundsFromBigBlatPsl(bigBlatPsl, opts, bedFh):
    geneIdLociCounts = defaultdict(int)
    bbpFh = pyBigWig.open(bigBlatPsl)
    for chrom in sorted(bbpFh.chroms()):
        geneBoundsForChrom(bbpFh, chrom, bbpFh.chroms(chrom), geneIdLociCounts, opts, bedFh)

def main(args):
    sourceAnnots = loadSourceAnnotBed(args.sourceAnnot) if args.sourceAnnot is not None else None
    opts = BoundsOpts(nameField=args.nameField,
                      hgncOnly=args.hgncOnly,
                      geneTypes=args.geneType,
                      sourceAnnots=sourceAnnots,
                      maxSourceExpansion=args.maxSourceExpansion,
                      minExons=args.minExons)
    with fileOps.opengz(args.geneBoundsBed, "w") as bedFh:
        geneBoundsFromBigBlatPsl(args.bigBlatPsl, opts, bedFh)

main(parseArgs())
